# 실행 컨텍스트
# 소스코드의 타입
  1. 전역 코드: 전역 변수를 관리하기 위한 전역 스코프 생성. var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수를 전역 객체의 프로퍼티와 메서드로 바인딩하고 참조하기 위해 전역 객체와 연결 -> 전역 실행 컨텍스트 생성
  2. 지역 스코프 생성, 지역 변수, 매개변수, 아규먼츠 객체 관리, 지역 스코프를 스코프 체인에 연결. -> 함수 실행 컨텍스트 생성
  3. eval 코드: 뭐.
  4. 모듈 코드: 나중에 보나?
# 소스코드의 평가와 실행
  1. 실행 전, 소스코드의 평가.
    - 변수, 함수 등의 선언문만 먼저 실행.
    - 식별자를 키로 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경 레코드)에 등록.
  2. 실행(런타임)
    - 참조는 스코프에서 검색해 취득하고,
    - 변수 값이 변경과 같은 실행 결과는 다시 스코프에 등록.
# 실행 컨텍스트의 역할
  - 코드가 실행되려면 스코프, 식별자, 코드 실행 순서 등의 관리가 필요하다.
  - 즉,
    1. 식별자를 스코프에 따라 구분하여 등록하고 상태 변화를 지속적으로 관리할 수 있어야 한다.
    2. 스코프는 중첩 관계에 의해 스코프 체인을 형성해야 한다.
    3. 현재 실행 중인 코드의 실행 순서를 변경할 수 있어야 하며 다시 되돌아갈 수도 있어야 한다.
  - 이 일을 하는 게 실행 컨텍스트.
  - 식별자를 등록, 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 매커니즘이다.
  - 식별자와 스코프는 실행 컨텍스트의 '렉시컬 환경'으로 관리.
  - 코드 실행 순서는 '실행 컨텍스트 스택'으로 관리
# 실행 컨텍스트 스택
  - 스택 자료구조.(선입후출)
  - 실행되는 실행 컨텍스트가 추가(push), 실행 끝나면 삭제(pop).
  - 전역 코드와 함수 코드로 구분되어서 진행 되고,
  - 각 코드는 실행 전에 평가 단계를 거친다.
  - 선입후출 구조로, 나중에 실행된 코드가 종료되면, 이전에 실행되던 코드로 돌아간다.
  - 스택의 최상위에 존재하는 실행 컨텍스트가 현재 진행 중인 코드의 실행 컨텍스트. 이걸 '실행 중인 실행 컨텍스트'라고 부른다.
# 렉시컬 환경
  - 식별자와 식별자에 비인딩된 값, 그리고 상위 스코프에 대한 참조를 기록하는 자료구조.
  - 즉, 식별자와 스코프를 관리한단 거지.
  - 두 개를 관리해야 하네? 두 개의 컴포넌트.
    1. 환경 레코드: 식별자를 등록하고 식별자에 바인딩된 값을 구분하는 저장소.
    2. 외부 렉시컬 환경에 대한 참조: 단방향 링크드 리스트인 스코프 체인 구현.
# 실행 컨텍스트의 생성과 식별자 검색 과정
  1. 전역 객체 생성
    - 전역 객체는 전역 코드가 평가되기 이전에 생성. 빌트인 전역 프로퍼티/함수/객체 등이 있고, 동작 환경에 따라 호스트 객체를 포함.
    - 이 전역 객체도 Object.prototype을 상속 받는다.
  2. 전역 코드 평가
    1. 전역 실행 컨텍스트 생성
    2. 전역 렉시컬 환경 생성
      1. 전역 환경 레코드 생성
        1. 객체 환경 레코드 생성
        2. 선언적 환경 레코드 생성
      2. this 바인딩
      3. 외부 렉시컬 환경에 대한 참조 결정
  3. 전역 코드 실행
  4. (함수 호출을 만나면) 함수 코드 평가
    1. 함수 실행 컨텍스트 생성
    2. 함수 렉시컬 환경 생성
      1. 함수 환경 레코드 생성
      2. this 바인딩
      3. 외부 렉시컬 환경에 대한 참조 결정
  5. 함수 코드 실행
  6. 함수 코드 실행 종료
  7. 전역 코드 실행 종료
# 실행 컨텍스트와 블록 레벨 스코프
  - 소스코드는 전역 코드와 함수 코드로 구분하니까,
  - 블록 레벨 스코프의 코드 블록은 따로 실행 컨텍스트를 만들지 않는다.
  - 근데 let/const는 블록 레벨 스코프를 만들잖아?
  - 이를 위해 블록 레벨 스코프는,
  - 선언적 환경 레코드를 갖는 렉시컬 환경을 새롭게 생성하여 기존의 전역 렉시컬 환경을 교체한다.
  - 즉, 실행 컨텍스트는 그대로 둔 상태에서,
  - 연결되어 있던 렉시컬 환경을 '선언적 환경 레코드를 갖는 렉시컬 환경'으로 교체.
  - 새로 연결된 렉시컬 환경은 기존의 렉시컬 환경을 상위 스코프로 갖는다.
  - 코드 블록이 끝나면, 이전의 렉시컬 환경으로 복귀.
  - 만약 코드 블록 내에 함수가 있다면, 이 함수의 상위 스코프는 코드 블록이 생성한 렉시컬 환경(선언적 환경 레코드를 갖는 렉시컬 환경).
---
# 클로저
  - 중첩 함수에서,
  - 내부 함수가 외부 함수보다 오래 살아남으며,
  - 외부 함수가 갖는 식별자를 내부 함수가 참조할 때,
  - 그 내부 함수를 클로저라고 부른다.
# 렉시컬 스코프
  - 렉시컬 환경의 “외부 렉시컬 환경에 대한 참조”에 저장할 참조값, 즉 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정된다.
# 함수 객체의 내부 슬롯 [[Envirobnment]]
  - 함수 객체는 호출과 상관없이, 자신이 정의된 환경, 상위 스코프를 기억해야 한다.
  - 이를 위해 함수 객체는 함수 정의가 평가 될 때,(런타임 이전에) 내부 슬롯 [[Environment]] 에 상위 스코프의 참조를 저장한다.
  - 이 상위 스코프는 '현재 실행 중인 실행 컨텍스트'의 렉시컬 환경이다.
  - 내부 슬롯에 기억하므로, 함수객체가 존재하는 한, 함수는 상위 스코프를 기억한다.
  - 후에 함수가 호출 되어 함수 코드가 평가되기 시작하면,
  - 함수 렉시컬 환경의 구성 요소인 외부 렉시컬 환경에 대한 참조에는 함수 객체의 내부 슬롯 [[Environment]]에 저장된 렉시컬 환경의 참조가 할당된다.
# 클로저와 렉시컬 환경
  - 중첩 함수에서, 외부 함수가 실행이 종료 되었을 때,
  - 외부 함수의 실행 컨텍스트는 스택에서 제거되지만, 렉시컬 환경까지 소멸하는 것은 아니다.(가비지 컬렉터가 처리하지 않는다.)
  - 내부 함수의 [[Environment]]에 의해 참조되고 있기 때문.
  - 내부 함수가 다른 곳(변수 등)에서 참조되고 있다면,
  - 외부 함수 없이 내부 함수를 호출할 수 있고, 이 때 외부 함수 객체의 변수에도 접근할 수 있다.
  - 모든 함수는 상위 스코프를 기억하므로, 이론적으로 모든 함수는 클로저지만,
  - 일반적으로 모든 함수를 클로저라고는 하지 않는다.
  - 클로저는,
    1. 상위 스코프의 식별자를 참조한다.
    2. 상위 스코프보다 생명 주기가 길다.
  - 를 만족해야 한다.
  - 클로저에 의해 참조되는 상위 스코프의 변수는 '자유 변수'.
# 클로저의 활용
  - 클로저는 상태(state)를 안전하게 변경하고 유지하기 위해 사용한다. 다시 말해, 상태가 의도치 않게 변경되지 않도록 상태를 안전하게 은닉(information hiding)하고 특정 함수에게만 상태 변경을 허용하기 위해 사용한다.
  ```
  // 카운트 상태 변경 함수
  const increase = (function () {
    // 카운트 상태 변수
    let num = 0;

    // 클로저
    return function () {
      // 카운트 상태를 1만큼 증가 시킨다.
      return ++num;
    };
  }());

  console.log(increase()); // 1
  console.log(increase()); // 2
  console.log(increase()); // 3
  ```
  ```
  const counter = (function () {
    // 카운트 상태 변수
    let num = 0;

    // 클로저인 메서드를 갖는 객체를 반환한다.
    // 객체 리터럴은 스코프를 만들지 않는다.
    // 따라서 아래 메서드들의 상위 스코프는 즉시 실행 함수의 렉시컬 환경이다.
    return {
      // num: 0, // 프로퍼티는 public하므로 은닉되지 않는다.
      increase() {
        return ++num;
      },
      decrease() {
        return num > 0 ? --num : 0;
      }
    };
  }());

  console.log(counter.increase()); // 1
  console.log(counter.increase()); // 2

  console.log(counter.decrease()); // 1
  console.log(counter.decrease()); // 0
  ```
  ```
  const Counter = (function () {
    // ① 카운트 상태 변수
    let num = 0;

    function Counter() {
      // this.num = 0; // ② 프로퍼티는 public하므로 은닉되지 않는다.
    }

    Counter.prototype.increase = function () {
      return ++num;
    };

    Counter.prototype.decrease = function () {
      return num > 0 ? --num : 0;
    };

    return Counter;
  }());

  const counter = new Counter();

  console.log(counter.increase()); // 1
  console.log(counter.increase()); // 2

  console.log(counter.decrease()); // 1
  console.log(counter.decrease()); // 0
  ```
  - 변수 값은 누군가에 의해 언제든지 변경될 수 있어 오류 발생의 근본적 원인이 될 수 있다. 외부 상태 변경이나 가변(mutable) 데이터를 피하고 불변성(immutability)을 지향하는 함수형 프로그래밍에서 부수 효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이기 위해 클로저는 적극적으로 사용된다.
  - 아래의 클로저는, 내용은 같지만 서로 다른 렉시컬 환경을 참조하는 클로저
  ```
  // 함수를 인수로 전달받고 함수를 반환하는 고차 함수
  // 이 함수는 카운트 상태를 유지하기 위한 자유 변수 counter를 기억하는 클로저를 반환한다.
  function makeCounter(predicate) {
  // 카운트 상태를 유지하기 위한 자유 변수
  let counter = 0;

    // 클로저를 반환
    return function () {
      // 인수로 전달 받은 보조 함수에 상태 변경을 위임한다.
      counter = predicate(counter);
      return counter;
    };
  }

  // 보조 함수
  function increase(n) {
    return ++n;
  }

  // 보조 함수
  function decrease(n) {
    return --n;
  }

  // 함수로 함수를 생성한다.
  // makeCounter 함수는 보조 함수를 인수로 전달받아 함수를 반환한다
  const increaser = makeCounter(increase); // ①
  console.log(increaser()); // 1
  console.log(increaser()); // 2

  // increaser 함수와는 별개의 독립된 렉시컬 환경을 갖기 때문에 카운터 상태가 연동하지 않는다.
  const decreaser = makeCounter(decrease); // ②
  console.log(decreaser()); // -1
  console.log(decreaser()); // -2
  ```
  - 아래와 같이 수정
  ```
  // 함수를 반환하는 고차 함수
  // 이 함수는 카운트 상태를 유지하기 위한 자유 변수 counter를 기억하는 클로저를 반환한다.
  const counter = (function () {
    // 카운트 상태를 유지하기 위한 자유 변수
    let counter = 0;

    // 함수를 인수로 전달받는 클로저를 반환
    return function (predicate) {
      // 인수로 전달 받은 보조 함수에 상태 변경을 위임한다.
      counter = predicate(counter);
      return counter;
    };
  }());

  // 보조 함수
  function increase(n) {
    return ++n;
  }

  // 보조 함수
  function decrease(n) {
    return --n;
  }

  // 보조 함수를 전달하여 호출
  console.log(counter(increase)); // 1
  console.log(counter(increase)); // 2

  // 자유 변수를 공유한다.
  console.log(counter(decrease)); // 1
  console.log(counter(decrease)); // 0
  ```
# 캡슐화와 정보 은닉
  - 캡슐화(encapsulation)는 객체의 상태(state)를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작(behavior)인 메서드를 하나로 묶는 것을 말한다. 캡슐화는 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 하는데 이를 정보 은닉(information hiding)이라 한다.
  - 즉시 실행 함수를 활용하여 생성자 함수와 프로토타입 프로퍼티 추가를 묶음.
  - 이 경우 클로저를 단 한번 생성하기 대문에, 인스턴스가 여러 개 만들어지면 동일한 상위 스코프를 사용하게 된다.
  - 자바스크립트는 정보 은닉을 완전하게 지원하지 않는다. 인스턴스 메서드를 사용한다면 자유 변수를 통해 private을 흉내 낼 수는 있지만 프로토타입 메서드를 사용하면 이마저도 불가능해진다.
  - 클래스에 private 필드를 정의할 수 있는 표준 사양이 제안되어 있는데, 이건 나중에.
# 자주 발생하는 실수
  ```
  var funcs = [];

  for (var i = 0; i < 3; i++) {
    funcs[i] = function () { return i; }; // ①
  }

  for (var j = 0; j < funcs.length; j++) {
    console.log(funcs[j]()); // ②
  }
  ```
  - 함수 레벨 스코프 특성으로 인해 for 문의 초기화 문에서 var 키워드로 선언한 변수가 전역 변수가 되기 때문에 발생하는 현상.
  - 아래처럼 수정할 수 있는데,
  ```
  var funcs = [];

  for (var i = 0; i < 3; i++){
    funcs[i] = (function (id) { // ①
      return function () {
        return id;
      };
    }(i));
  }

  for (var j = 0; j < funcs.length; j++) {
    console.log(funcs[j]());
  }
  ```
  - let을 사용하면 깔금하게 해결.
  ```
  const funcs = [];

  for (let i = 0; i < 3; i++) {
    funcs[i] = function () { return i; };
  }

  for (let i = 0; i < funcs.length; i++) {
    console.log(funcs[i]()); // 0 1 2
  }
  ```
  - let/const 선언을 사용하면, 블록 레벨 스코프가 적용 되어, for문의 코드 블록이 실행될 때마다 새로운 렉시컬 환경이 만들어진다.
  - 이 때 코드 블록 내에 정의한 함수가 있다면, 이 함수의 상위 스코프는 새로운 렉시컬 환경이 된다.
  - 독립적인 렉시컬 환경을 각각 갖으므로, 식별자의 값을 유지할 수 있다.
  - 단, 이는 반복문의 코드 블록 내부에서 함수를 정의할 때 의미가 있다. 반복문의 코드 블록 내부에 함수 정의가 없는 반복문이 생성하는 새로운 렉시컬 환경은 반복 직후, 아무도 참조하지 않기 때문에 가비지 컬렉션의 대상이 된다.
  - 고차 함수를 사용하는 방법도 있는데, 나중에 다시 배움.