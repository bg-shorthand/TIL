# 변수
  -  하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
    1. 아무리 복잡한 애플리케이션이라 해도 데이터를 입력(input)받아 처리하고 그 결과를 출력(output)하는 것이 전부다.
    2. 변수는 그 데이터를 관리하기 위한 핵심 개념
## 변수가 필요한 이유
  1. 데이터 관리는 값을 메모리셀에 저장하는 것.
  2. 근데 그 메모리셀에 메모리 주소로 직접 접근하는 건 위험해.
  3. 실수로 운영체제가 사용하고 있는 메모리를 수정하거나 지우면 어떡해?
  4. 그러니까 직접 접근하지 않고,
  5. 메모리 공간을 식별하기 위한 이름을 붙여 관리.
  6. 그게 변수임.
    - 따라서 변수는, 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
    - 프로그래밍 언어에서 값을 저장하고 참조(읽어 들이는)하는 메커니즘으로,
    - 값의 위치를 가리키는 상징적인 '이름'
    - 메모리 주소가 아닌 다른 명명을 한다는 것은,
    - 사람이 이해할 수 있는 언어로 저장된 값의 의미를 명확히 할 수 있다는 것.
    - 명확한 네이밍으로 코드를 이해하기 쉽게 해야겠지?
    - 협업과 품질 향상에 도움
## 할당과 참조
  1. 할당: 변수에 값을 저장하는 것
  2. 참조: 변수에 저장된 값을 읽어 들이는 것
## 식별자
  - 어떤 값을 구별해서 식별할 수 있는 고유한 이름
  - 변수에서만 사용되는 용어가 아니라, 변수, 함수, 클래스 등의 이름을 모두 지칭함.(자바스크립트에서는 함수도 값)
  - 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름
    1. 변수의 식별자는 메모리 주소와 매핑(그래야 거기 저장된 값을 찾지)
    2. 네이밍 규칙을 준수해야 함
## 변수 선언
  - 변수를 생성하는 것.
  - 값을 저장하기 위한 메모리 공간을 확보하고, 그 주소에 변수 이름을 연결,
  - 값을 저장할 수 있게 준비하는 것.
  - 변수를 사용하려면 꼭 필요해. 선언하지 않은 식별자에 접근하면 참조 에러(ReferenceError)
    1. 확보된 메모리 공간은 해제되기 전까지 보호되므로, 안전하게 사용 가능.
    2. var, let, const 키워드를 사용.
    3. 변수 선언에 의해 준비된 메모리 공간에는, undefined 라는 값이 암묵적으로 할당
    4. 즉, 변수 선언은 두 단계를 거침
      1. 선언 단계: 메모리 공간 확보, 변수 이름 연결, 자바스크립트 엔진에 변수의 존재를 알림.
      2. 초기화 단계: 암묵적으로 undefined라는 값을 할당.
    5. 초기화 단계를 거치지 않으면, 이전에 저장되어 있던 값(쓰레기 값)이 남아 있을 수 있다.
## 변수 선언의 실행 시점
  - 변수 선언은 런타임 이전 단계에서 먼저 실행됨.
    1. 자바스크립트 엔진은 소스코드를 실행하기 앞서 소스코드 평가 과정을 거침.
    2. 이 과정에서 변수 선언을 포함한 모든 선언문을 먼저 실행.
    3. 따라서, 변수 선언이 어느 위치에 있든 변수 참조 가능
    4. 이처럼 변수 선언문이 선두로 끌어올려지는 것처럼 동작하는 자바스크립트 특유의 동작을 '호이스팅'이라고 함
## 변수 선언과 할당의 단축, 그리고 호이스팅
  1. 변수 선언과 할당은 하나의 문으로 단축해 쓸 수 있음.
  2. 하지만 동작은 나눠서 해.
  3. 호이스팅에 의해 변수 선언'만' 먼저 실행
  4. 근데 말이야,
  5. 할당은 이전의 undefined 값을 지우고 할당 하는 게 아니라, 새로운 메모리 공간을 확보하고 거기에 저장(이게 무슨 의미지? 선언과 할당이 명확히 구분되어 동작한단 의미?)
## 값의 재할당
  1. var 키워드로 선언한 변수는 값이 변할 수 있는 변수.
  2. 할당과 마찬가지로 새로운 메모리 공간을 확보하고 거기에 저장
  3. 불필요해진 이전의 메모리 공간은 가비지 콜렉터에 의해 자동 해제
    - 가비지 콜렉터: 애플리케이션이 할당(allocate)한 메모리 공간을 주기적으로 검사하여 더 이상 사용되고 있지 않는 메모리를 해제(release)하는 기능
    - 가비지 콜렉터가 내장된 언어를 '매니지드 언어', 없는 언어를 '언매니지드 언어'라고 함.
    - 매니지드 언어는 개발자가 명시적으로 메모리를 할당하고 해제할 수 없다. 일정한 생산성을 확보할 수 있지만, 성능 면에서는 손실을 감수할 수밖에 없다.
    - 언매니지드 언어는 개발자가 직접 메모리를 할당, 해제할 수 있는 메모리 제어 기능을 제공. 개발자의 역량에 따라 최적의 성능을 기대할 수 있지만, 반대의 경우 폭망.
## 식별자 네이밍 규칙
  1. 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러 기호($)를 포함할 수 있다.
  2. 단, 식별자는 특수문자를 제외한 문자, 언더스코어(_), 달러 기호($)로 시작해야 한다. 숫자로 시작하는 것은 허용하지 않는다.
  3. 예약어는 식별자로 사용할 수 없다.
  4. 유니코드 문자 사용으로 한글 등도 사용가능하지만 권장 안함
  5. 대소문자를 구분함
  6. 명확한 의미의 이름을 사용.
  7. 네이밍 컨벤션은 어떤 것을 사용해도 좋으나, 통일은 해야지.
  8. 일반적으로, 변수나 함수의 이름에는 카멜 케이스를 사용하고 생성자 함수, 클래스의 이름에는 파스칼 케이스를 사용
### 용어
  1. 키워드: 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어. 자바스크립트 엔진은 키워드를 만나면 자신이 수행해야 할 약속된 동작을 수행
  2. 예약어: 프로그래밍 언어에서 사용되고 있거나 사용될 예정인 단어를 말한다. 자바스크립트의 예약어는 다음과 같다.
    - await break case catch class const continue debugger default delete do else enum export extends false finally for function if implements* import in Instanceof interface* let* new null package* private* protected* public* return super static* switch this throw true try typeof var void while with yield*
    - * 식별자로 사용 가능하나 Strict Mode에서는 사용 불가
---
# 표현식과 문
## 값
  - 식(표현식, expression)이 평가(evaluate)되어 생성된 결과
    1. '표현식'을 '평가'하다
    2. 변수에 할당되는 것이 '값'
## 값을 생성하는 방법
  1. 리터럴
    - 사람이 이해할 수 있는 문자(아라비아 숫자, 알파벳, 한글 등) 또는 약속된 기호(‘’, “”, ., [], {}, // 등)를 사용해 값을 생성하는 표기 방식
    - 자바스크립트 엔진은 런타임에 리터럴을 평가해 값을 생성. -> 리터럴은 값을 생성하기 위해 미리 약속된 표기법
    - 리터럴을 통해 생성할 수 있는 값
      1. 정수 리터럴 (ex. 100)
      2. 부동소수점 리터럴 (ex. 1.5)
      3. 2진수 리터럴 (ex. 0b01000001 -> 0b로 시작)
      4. 8진수 리터럴 (ex. 0o101 -> 0o로 시작)
      5. 16진수 리터럴 (ex. 0x41 -> 0x로 시작)
      6. 문자 리터럴 (ex. 'hello' "world")
      7. 불리언 리터럴 (ex. true false)
      8. null 리터럴
      9. undefined 리터럴
      10. 객체 리터럴 (ex. { name: 'Lee', address: 'Seoul' })
      11. 배열 리터럴 (ex. [ 1, 2, 3 ])
      12. 함수 리터럴 (ex. function() {})
      13. 정규표현식 리터럴 (ex. /[A-Z]+/g)
  2. 표현식 
    - 값으로 평가될 수 있는 문(statement)
    - 값으로 평가되면 표현식 -> 리터럴도 값으로 평가되므로, 리터럴도 표현식이다. -> 식별자 '참조' 역시 값으로 평가되므로 표현식
    - 표현식과 값은 동치, 즉 표현식은 값처럼 사용될 수 있다 -> 문법적으로 값이 위치해야 할 위치에 표현식이 위치 가능.
## 문(statement)
  - 프로그램을 구성하는 기본 단위이자 최소 실행 단위
  - 문의 집합으로 이뤄진 것이 바로 프로그램이며, 문을 작성하고 순서에 맞게 나열하는 것이 프로그래밍
    1. 문은 여러 토큰으로 이루어진다.
      - 토큰: 문법적 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소
      - 키워드, 식별자, 연산자, 리터럴, 세미콜론 따위
    2. 문은 '명령문'이라고도 부른다 -> 문이 실행되면 명령이 실행되고, 무언가 일어남.
    3. 선언문, 할당문, 조건문, 반복문 등으로 구분
    4. 세미콜론(;)
      - 문의 종료를 표시
      - 자바스크립트 엔진은 세미콜론으로 문의 종료를 파악하고 순차적으로 실행
      - 단, 문을 중괄호로 묶은 블록 뒤에는 세미콜론 표시 안함 -> 코드 블록은 언제나 자체 종결성을 갖기 때문
      - 세미콜론은 생략 가능. 자바스크립트 엔진의 세미콜론 자동 삽입 기능이 암묵적으로 수행되기 때문
## 표현식과 문
  - 표현식은 문의 일부분일 수도, 그 자체로 문일 수도 있다.
  - 문이 값으로 평가 되면 표현식. 아닐 수도 있지
  - 확인하는 가장 간단한 방법은 문을 변수에 할당해 보는 것. -> 값으로 평가되는 표현식이면 할당이 될 거고, 값으로 평가되지 않으면 에러.
## 용어
  1. 완료 값: 크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 undefined를 출력한다. 이를 완료 값이라 한다. 완료 값은 표현식의 평가 결과가 아니다.
---
# 데이터 타입
  - 값의 종류
  - 원시 타입: 숫자, 문자열, 불리언, undefined, null, 심벌
  - 객체 타입: 객체, 함수, 배열 등 (함수도 값이다!)
## 원시 타입
  - 변경 불가능한 값
  - 변수에 다른 원시타입을 할당하는 경우는 기존의 값이 변경되는게 아니라 새로운 값이 생성되어 할당되는 것.
    1. 숫자 타입
      - 자바스크립트는 정수와 실수를 구분하지 않고 하나의 숫자 타입만 제공
      - 2진수, 8진수, 16진수를 표현하기 위한 데이터 타입을 제공하지 않으므로, 이들 값을 참조하면 모두 10진수로 해석
      - 숫자 타입의 세 가지 특별한 값
        1. 10/0 -> infinity: 양의 무한대
        2. 10/-0 -> -infinity: 음의 무한대
        3. 1*"string" -> NaN: 산술 연산 불가(NAN, Nan 등과 다름. 자바스크립트 엔진은 대소문자를 구별하므로, 이와 같은 표현은 식별자로 해석)
    2. 문자열 타입
      - 유니코드 문자로, 전 세계 대부분의 문자를 표현 가능
      - '', "", `` 으로 감싸 표현 가능. 일반적으론 ''
      - 키워드, 식별자 등과 구분하기 위해 감싸서 표현
      - 자바스크립트의 문자열은 원시 타입이며 변경 불가능한 값 (immutable value)다. 이것은 문자열이 생성되면 그 문자열을 변경할 수 없다는 것을 의미한다
      - 문자열 연산자 + 로 연결 가능
      - 템플릿 리터럴
        - 멀티라인 문자열(multi-line string), 표현식 삽입(expression interpolation), 태그드 템플릿(tagged template) 등 편리한 문자열 처리 기능을 제공
        - 런타임에 문자열로 변환되어 처리
        - 백틱(``)을 사용해 표현
          1. 이스케이프 시퀀스를 사용하지 않고도 줄바꿈, 공백 등이 그대로 적용
          2. ${ } 을 통해 표현식 삽입 가능. 안의 표현식은 강제로 문자열로 바뀜(표현식 삽입은 반드시 템플릿 리터럴 에서만. 일반 문자열에서는 ${}도 문자열로 취급)
    3. 불리언
      - true, false
    4. undefined
      - var 키워드로 선언한 변수는 undefined 로 암묵적 초기화
      - 엔진이 변수를 초기화 하는데 쓰는 undefined를 개발자가 의도적으로 할당하면 취지와 어긋나,
      - 권장하지 않음.
      - 변수에 값이 없다는 걸 명시하고 싶을 땐, null을 써
    5. null
      - 변수에 값이 없다는 걸 명시
      - 이전에 할당 되어 있던 값에 대한 참조를 명시적으로 제거
      - 값은 가비지 가비지 콜렉터가 지움
    6. symbol 타입
      - 다른 값과 중복되지 않는 유일무이한 값
      - 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용
## 객체 타입
  - 데이터는 크기가 정해져 있지 않고 변수에 할당될 때 값이 직접 해당 변수에 저장될 수 없으며, 변수에는 데이터에 대한 참조만 저장된다. 참조는 참조 타입 데이터의 주소이지 해당 데이터의 값이 아니다.
  - 객체에 대해서는 후에 자세히 알아볼 텐데, 중요한 것은 자바스크립트는 객체 기반의 언어이며, 자바스크립트를 이루고 있는 거의 모든 것이 객체라는 것.
  - 이거 궁금한데, 일단 원시 타입 여섯 개의 데이터 타입 외의 값은 모두 객체
## 데이터 타입의 필요성
  1. 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
  2. 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해
  3. 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해
## 동적 타입 언어인 자바스크립트
  1. 정적 타입 언어와 동적 타입 언어
    - 정적 타입 언어: 변수를 선언할 때, 데이터 타입을 먼저 선언 -> 컴파일 때 타입이 맞는지를 확인하고, 안 맞으면 에러, -> 더욱 안정적인 코드의 구현 가능
    - 동적 타입 언어: 데이터 타입 선언이 따로 없음, 값에 따라 데이터 타입이 결정
      - 할당에 의해 타입이 결정(타입 추론)
      - 재할당으로 언제든 변수의 타입이 바뀔 수 있다-> 동적 타입 언어
      - 변수는 기본적으로 타입을 갖지 않지만, 연결된 값에 따라 타입을 갖게 됨
      - 변수에 자유롭게 할당을 할 수 있어 편리하지만, 단점이 있지
  2. 동적 타입 언어의 단점
    - 동적 타입 언어의 변수는 값을 확인하기 전에는 타입을 확신할 수 없다
    - 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동으로 변환되기도 한다
    - 유연성(flexibility)은 높지만 신뢰성(reliability)은 떨어진다
  3. 단점으로 인해 주의해야 할 점
    - 변수는 꼭 필요한 경우에 한해 제한적으로 사용
    - 변수의 유효 범위(스코프)는 최대한 좁게 만들어 변수의 부작용을 억제
    - 전역 변수는 최대한 사용하지 않도록
    - 변수보다는 상수를 사용해 값의 변경을 억제
    - 변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍
## 용어
  1. 이스케이프 시퀀스: 문자열에서, 줄바꿈 등의 공백(white space)을 표현하는 방법. (ex. \0)
  2. 라인 피드와 캐리지 리턴
    - 라인 피드(LF, Line Feed): 커서를 정지한 상태에서 종이를 한 줄 올리는 것
    - 캐리지 리턴(CR, Carriage Return): 종이를 움직이지 않고 커서를 맨 앞줄로 이동하는 것
    - 개행 방식의 차이
    - 운영체제마다 다른 개행 방식을 따르는데,
    - 대부분의 텍스트 에디터는 운영체제에 맞게 개행 방식을 바꿔줘
    - 자바스크립트에서 라인 피드와 캐리지 리턴은 모두 개행을 의미한다. 하지만 캐리지 리턴(\r)으로 개행하는 경우는 거의 없고 일반적으로 라인 피드(\n)를 사용해 개행한다.
  3. 트레이드 오프: 두 개의 정책 목표 가운데 하나를 달성하려고 하면 다른 목표의 달성이 늦어지거나 희생되는 모순적 관계
  4. 은 탄환: 고질적인 문제를 단번에 해결할 수 있는 명쾌한 해결책
