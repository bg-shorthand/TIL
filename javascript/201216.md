# 배열
  - 여러 개의 값을 순차적으로 나열한 자료 구조.
  - 요소: 배열이 가지고 있는 값(객체, 함수, 배열 등 자바스크립트에서 값으로 인정하는 모든 것이 들어갈 수 있다.)
  - 인덱스: 배열에서 요소의 위치(0부터 시작)
  - 요소에 접근할 때는 대괄호 표기법을 사용한다.
  - 배열은 배열의 길이를 나타내는 length 프로퍼티를 갖는다.
  - 인덱스와 length 프로퍼티를 갖기 때문에, for문으로 순차적으로 요소에 접근할 수 있다.
  - 배열은 객체 타입이다.
  - 배열은 리터럴, Array 생성자 함수, Array.of, Array.from 메서드로 생성할 수 있다.
  - Array.prototype이 배열을 위한 빌트인 메서드를 가지고 있다.
# 자바스크립트의 배열
  - 자료 구조에서 말하는 배열은, 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료 구조를 말한다. -> 밀집 배열.
  - 이러한 배열은 인덱스를 통해 효율적으로 요소에 접근할 수 있다는 장점이 있다.
  - 하지만 처음부터 끝까지 검색을 하는, '선형 검색'을 해야 한다는 단점.
  - 또한 배열의 요소를 삽입하거나 삭제하는 경우 배열의 요소를 연속적으로 유지하기 위해 요소를 이동시켜야 하는 단점.
  - 그런데 자바스크립트의 배열은,
  - 일반적인 배열의 동작을 흉내 낸 특수한 객체다.
  - 자바스크립트 배열은 인덱스를 나타내는 문자열을 프로퍼티로 가지며, length 프로퍼티를 갖는 특수한 객체다. -> 인덱스가 사실 프로퍼티 키. 요소는 프로퍼티 값.
  - 일반적인 배열보다 성능적인 면에서 느릴 수밖에 없지만,
  - 특정 요소를 검색하거나 요소를 삽입 삭제하는 경우에는 빠른 성능을 기대할 수 있다.
# length 프로퍼티와 희소 배열
# 배열 생성
  1. 배열 리터럴
  2. Array 생성자 함수
    ```
    const arr = new Array(10);
    ```
    - 전달된 인수가 1개이고 숫자인 경우 인수를 length 프로퍼티 값으로 가진 배열을 생성.
    - 이 때 생성된 배열은 요소가 없는 희소 배열.
    - 인수가 없는 경우 빈 배열.
    - 전달된 인수가 둘 이상이거나 숫자가 아닌 경우, 각각을 요소로 갖는 배열 생성.
    ```
    new Array(1, 2, 3); // -> [1, 2, 3]
    ```
    - new 연산자와 함께 호출하지 않더라도, 배열을 생성하는 생성자 함수로 동작한다.
    ```
    Array(1, 2, 3); // -> [1, 2, 3]
    ```
  3. Array.of
    - 인수를 요소로 갖는 배열을 생성. Array()와 달리 1개의 인수만 전달해도 요소로 생성.
    ```
    Array.of(1); // -> [1]
    Array.of(1, 2, 3); // -> [1, 2, 3]
    Array.of('string'); // -> ['string']
    ```
  4. Array.from
    - 유사 배열 객체(array-like object) 또는 이터러블 객체(iterable object)를 인수로 전달받아 배열로 변환하여 반환한다.
    ```
    Array.from({ length: 2, 0: 'a', 1: 'b' }); // -> ['a', 'b']
    Array.from('Hello'); // -> ['H', 'e', 'l', 'l', 'o']
    ```
    - 두번째 인수로 전달한 콜백 함수를 통해 값을 만들면서 요소를 채울 수 있다. 
    ```
    Array.form({ length: 3}, (_, i) => i); // [0, 1, 2]
    ```
    - 두번째 인수로 전달된 '콜백 함수의 첫번째 인수'는 순차적으로 도는 배열의 요소.
    - 두번째 인수는 인덱스.
# 배열 요소의 참조
# 배열 요소의 추가와 갱신
  - 인덱스가 아닌 프로퍼티 키로 추가된 배열의 '프로퍼티'는 length에 영향을 주지 않는다.
  - length 는 인덱스가 있는 요소(인덱스만 있는 경우도 제외)만 센다.
# 배열 요소의 삭제
  - 배열은 객체이기 때문에 delete 연산자를 사용할 수 있으나, 희소 배열로 만들어 버린다.
  - splice 메서드 써야지.
# 배열 메서드
  1. Array.isArray
    - 전달된 인수가 배열이면 true, 아니면 false.
  2. Array.prototype.indexOf
    - 인수로 전달된 요소를 검색하여 인덱스를 반환한다.
    - 요소가 여러 개 있다면 첫 번째로 검색된 요소의 인덱스를 반환한다.
    - 요소가 존재하지 않으면 -1을 반환한다.
    - 배열에 특정 요소가 존재하는지 확인할 때 유용하다.
    ```
    const foods = ['apple', 'banana', 'orange'];

    // foods 배열에 'orange' 요소가 존재하는지 확인한다.
    if (foods.indexOf('orange') === -1) {
      // foods 배열에 'orange' 요소가 존재하지 않으면 'orange' 요소를 추가한다.
      foods.push('orange');
    }

    console.log(foods); // ["apple", "banana", "orange"]
    ```
    - Array.prototype.includes를 사용할 수 있다.
    ```
    const foods = ['apple', 'banana'];

    // foods 배열에 'orange' 요소가 존재하는지 확인한다.
    if (!foods.includes('orange')) {
      // foods 배열에 'orange' 요소가 존재하지 않으면 'orange' 요소를 추가한다.
      foods.push('orange');
    }

    console.log(foods); // ["apple", "banana", "orange"]
    ```
  3. Array.prototype.push
    - 인수로 전달받은 모든 값을 원본 배열의 마지막 요소로 추가하고 변경된 length 프로퍼티 값을 반환한다.
    - push 메서드를 사용하지 않고 length 프로퍼티를 사용하여 배열의 마지막에 요소를 직접 추가할 수도 있다. 이 방법이 push 메서드보다 빠르다.
    - push 메서드는 원본 배열을 직접 변경하는 부수 효과가 있다. 따라서 push 메서드보다는 ES6의 스프레드 문법을 사용하는 편이 좋다. 스프레드 문법을 사용하면 함수 호출 없이 표현식으로 마지막에 요소를 추가할 수 있으며 부수 효과도 없다. 
    ```
    const arr = [1, 2];

    // ES6 스프레드 문법
    const newArr = [...arr, 3];
    console.log(newArr); // [1, 2, 3]
    ```
  4. Array.prototype.pop
    - 원본 배열에서 마지막 요소를 제거하고 제거한 요소를 반환한다. 원본 배열이 빈 배열이면 undefined를 반환한다. pop 메서드는 원본 배열을 직접 변경한다.
  5. Array.prototype.unshift
    - 인수로 전달받은 모든 값을 원본 배열의 선두에 요소로 추가하고 변경된 length 프로퍼티 값을 반환한다. unshift 메서드는 원본 배열을 직접 변경한다.
    - unshift 메서드는 원본 배열을 직접 변경하는 부수 효과가 있다. 따라서 unshift 메서드보다는 ES6의 스프레드 문법을 사용하는 편이 좋다. 스프레드 문법을 사용하면 함수 호출 없이 표현식으로 선두에 요소를 추가할 수 있으며 부수 효과도 없다.
    ```
    const arr = [1, 2];

    // ES6 스프레드 문법
    const newArr = [3, ...arr];
    console.log(newArr); // [3, 1, 2]
    ```
  6. Array.prototype.shift
    - shift 메서드는 원본 배열에서 첫 번째 요소를 제거하고 제거한 요소를 반환한다. 원본 배열이 빈 배열이면 undefined를 반환한다. shift 메서드는 원본 배열을 직접 변경한다.
  7. Array.prototype.concat
    - 인수로 전달된 값들(배열 또는 원시값)을 원본 배열의 마지막 요소로 추가한 새로운 배열을 반환한다. 인수로 전달한 값이 배열인 경우 배열을 해체하여 새로운 배열의 요소로 추가한다. 원본 배열은 변경되지 않는다.
    - push와 unshift 메서드는 원본 배열을 직접 변경하지만 concat 메서드는 원본 배열을 변경하지 않고 새로운 배열을 반환한다.
    - 인수로 전달받은 값이 배열인 경우 push와 unshift 메서드는 배열을 그대로 원본 배열의 마지막/첫 번째 요소로 추가하지만 concat 메서드는 인수로 전달받은 배열을 해체하여 새로운 배열의 마지막 요소로 추가한다.
  8. Array.prototype.splice
    - 세 개의 매개변수를 받는다.
    - (요소를 제거하기 시작할 인덱스, 제거할 요소의 개수(옵션), 제거한 위치에 삽입할 요소 목록(옵션))
    - 첫번째 요소가 음수인 경우, 배열의 끝에서부터.
  9. Array.prototype.slice
    - 인수로 전달된 범위의 요소들을 복사하여 배열로 반환한다. 
    - 두 개의 매개변수를 받는다.
    - (복사를 시작할 인덱스, 복사를 종료할 인덱스)
    - 종료할 인덱스에 해당하는 요소는 복사되지 않는다. 두번째 인수는 생략 가능하며, 기본값은 length 프로퍼티 값이다.(생략시 다 복사된다.)
    - 첫번째 인수가 음수인 경우, 배열의 끝에서부터 요소를 복사한다.
    - 인수를 모두 생략하면 원본 전체를 복사한다.
    - 이 때는 얕은 복사.
    - 복사본을 생성하는 것을 이용하여, 유사 배열 객체를 배열로 변환할 수 있다.
    - Array.from 메서드를 사용하면 더욱 간단하지.
  10. prototype.join
    - 원본 배열의 모든 요소를 문자열로 변환한 후, 인수로 전달받은 문자열, 즉 구분자(separator)로 연결한 문자열을 반환한다.
    ```
    arr.join(); // -> '1,2,3,4';
    arr.join(''); // -> '1234'
    arr.join(':'); // -> '1:2:3:4'
    ```
  11. Array.prototype.reverse
    - 원본 배열의 순서를 반대로 뒤집는다. 이때 원본 배열이 변경된다. 반환값은 변경된 배열이다.
  12. Array.prototype.fill
    - 인수로 전달받은 값을 배열의 처음부터 끝까지 요소로 채운다. 이때 원본 배열이 변경된다.
    - 두 번째 인수로 요소 채우기를 시작할 인덱스를 전달할 수 있다.
    - 세 번째 인수로 요소 채우기를 멈출 인덱스를 전달할 수 있다.
    - fill 메서드로 요소를 채울 경우 모든 요소를 하나의 값만으로 채울 수밖에 없다는 단점이 있다. 하지만 Array.from 메서드를 사용하면 두 번째 인수로 전달한 콜백 함수를 통해 요소값을 만들면서 배열을 채울 수 있다.
  13. Array.prototype.includes
    - 배열 내에 특정 요소가 포함되어 있는지 확인하여 true 또는 false를 반환한다.
    - (검색할 대상, 검색을 시작할 인덱스)
    - 인수로 전달된 요소를 검색하여 인덱스를 반환하는 indexOf 메서드를 사용하여도 배열 내에 특정 요소가 포함되어 있는지 확인할 수 있다. 하지만 indexOf 메서드를 사용하면 반환값이 -1인지 확인해 보아야 하고 배열에 NaN이 포함되어 있는지 확인할 수 없다는 문제가 있다.
  14. Array.prototype.flat
    - 인수로 전달한 깊이만큼 재귀적으로 배열을 평탄화한다.
    ```
    // 중첩 배열을 평탄화하기 위한 깊이 값의 기본값은 1이다.
    [1, [2, [3, [4]]]].flat();  // -> [1, 2, [3, [4]]]
    [1, [2, [3, [4]]]].flat(1); // -> [1, 2, [3, [4]]]

    // 중첩 배열을 평탄화하기 위한 깊이 값을 2로 지정하여 2단계 깊이까지 평탄화한다.
    [1, [2, [3, [4]]]].flat(2); // -> [1, 2, 3, [4]]
    // 2번 평탄화한 것과 동일하다.
    [1, [2, [3, [4]]]].flat().flat(); // -> [1, 2, 3, [4]]

    // 중첩 배열을 평탄화하기 위한 깊이 값을 Infinity로 지정하여 중첩 배열 모두를 평탄화한다.
    [1, [2, [3, [4]]]].flat(Infinity); // -> [1, 2, 3, 4]
    ```
# 배열 고차 함수
  - 함수를 인수로 전달받거나 함수를 반환하는 함수를 말한다.
  1. Array.prototype.sort
    - 배열의 요소를 정렬한다. 원본 배열을 직접 변경하며 정렬된 배열을 반환한다.
    - 기본적으로 오름차순.
    - 내림차순으로 요소를 정렬하려면 sort 메서드를 사용하여 오름차순으로 정렬한 후 reverse 메서드를 사용하여 요소의 순서를 뒤집는다.
    - 숫자 요소를 정렬할 때는 sort 메서드에 정렬 순서를 정의하는 비교 함수를 인수로 전달해야 한다.
    ```
    points.sort((a, b) => a - b);
    console.log(points); // [1, 2, 5, 10, 25, 40, 100]

    points.sort((a, b) => b - a);
    console.log(points); // [100, 40, 25, 10, 5, 2, 1]
    ```
  2. Array.prototype.forEach
    - 자신의 내부에서 반복문을 실행한다. 즉, forEach 메서드는 반복문을 추상화한 고차 함수로서 내부에서 반복문을 통해 자신을 호출한 배열을 순회하면서 수행해야할 처리를 콜백 함수로 전달받아 반복 호출한다.
    - forEach 메서드는 콜백 함수를 호출할 때 3개의 인수, 즉 forEach 메서드를 호출한 배열의 요소값과 인덱스, forEach 메서드를 호출한 배열(this)을 순차적으로 전달한다.
    - forEach 메서드의 두 번째 인수로 forEach 메서드의 콜백 함수 내부에서 this로 사용할 객체를 전달할 수 있다.
    - for 문과는 달리 break, continue 문을 사용할 수 없다. 다시 말해, 배열의 모든 요소를 빠짐없이 모두 순회하며 중간에 순회를 중단할 수 없다.
    - 희소 배열의 경우 존재하지 않는 요소는 순회 대상에서 제외된다.
  3. Array.prototype.map
    - 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백 함수를 반복 호출한다. 그리고 콜백 함수의 반환값들로 구성된 새로운 배열을 반환한다. 이때 원본 배열은 변경되지 않는다.
    - forEach 메서드는 언제나 undefined를 반환하고, map 메서드는 콜백 함수의 반환값들로 구성된 새로운 배열을 반환하는 차이가 있다. 즉, forEach 메서드는 단순히 반복문을 대체하기 위한 고차 함수이고, map 메서드는 요소값을 다른 값으로 매핑(mapping)한 새로운 배열을 생성하기 위한 고차 함수다.
    - forEach 메서드와 마찬가지로 map 메서드의 콜백 함수는 map 메서드를 호출한 배열의 요소값과 인덱스, map 메서드를 호출한 배열 자체, 즉 this를 순차적으로 전달받을 수 있다.
    - forEach 메서드와 마찬가지로 map 메서드의 두 번째 인수로 map 메서드의 콜백 함수 내부에서 this로 사용할 객체를 전달할 수 있다.
  4. Array.prototype.filter
    - 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백 함수를 반복 호출한다. 그리고 콜백 함수의 '반환값이 true'인 요소로만 구성된 새로운 배열을 반환한다. 이때 원본 배열은 변경되지 않는다.
    - forEach, map 메서드와 마찬가지로 filter 메서드의 콜백 함수는 filter 메서드를 호출한 배열의 요소값과 인덱스, filter 메서드를 호출한 배열 자체, 즉 this를 순차적으로 전달받을 수 있다. 
    - forEach, map 메서드와 마찬가지로 filter 메서드의 두 번째 인수로 filter 메서드의 콜백 함수 내부에서 this로 사용할 객체를 전달할 수 있다.
    - filter 메서드는 자신을 호출한 배열에서 특정 요소를 제거하기 위해 사용할 수도 있다.
    ```
    class Users {
      constructor() {
        this.users = [
          { id: 1, name: 'Lee' },
          { id: 2, name: 'Kim' }
        ];
      }

      // 요소 추출
      findById(id) {
        // id가 일치하는 사용자만 반환한다.
        return this.users.filter(user => user.id === id);
      }

      // 요소 제거
      remove(id) {
        // id가 일치하지 않는 사용자를 제거한다.
        this.users = this.users.filter(user => user.id !== id);
      }
    }

    const users = new Users();

    let user = users.findById(1);
    console.log(user); // [{ id: 1, name: 'Lee' }]

    // id가 1인 사용자를 제거한다.
    users.remove(1);

    user = users.findById(1);
    console.log(user); // []
    ```
    - filter 메서드를 사용해 특정 요소를 제거할 경우 특정 요소가 중복되어 있다면 중복된 요소가 모두 제거된다. 특정 요소를 하나만 제거하려면 indexOf 메서드를 통해 특정 요소의 인덱스를 취득한 다음 splice 메서드를 사용한다.
  5. Array.prototype.reduce
    