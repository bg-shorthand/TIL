# 함수와 일급 객체
# 일급 객체
  - 일급 객체의 조건
    1. 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.
    2. 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
    3. 함수의 매개변수에게 전달할 수 있다.
    4. 함수의 반환값으로 사용할 수 있다.
  - 자바스크립트의 함수는 위의 조건을 모두 만족하므로, 일급 객체다.
  - 객체왈 동일하게 사용할 수 있단 의미이고,
  - 값과 동일하게 취급,
  - 값을 사용하는 곳이라면 어디든지 리터럴로 정의 가능,
  - 런타임에 함수 객체로 평가.
  - 객체와 같지만, 일반 객체에는 없는 함수 고유의 프로퍼티를 갖는다.
# 함수 객체의 프로퍼티
  - arguments, caller, length, name, propotype.
  - 특히, __proto__는 접근자 프로퍼티로, Object.prototype 객체의 프로퍼티를 상속 받은 것.
  - Object.prototype의 프로퍼티로 모든 객체가 사용할 수 있다.(프로토타입)
  1. arguments: 함수 호출 시 전달된 인수들의 정보를 담고 있는 순회 가능한(이터러블iterable) 유사 배열 객체. 인수를 프로퍼티 값으로 가지며, 프로퍼티 키는 인수의 순서. length프로퍼티는 인수의 개수, callee 프로퍼티는 arguments 객체를 생성한 함수, 즉 자기 자신. 가변 인자 함수를 구현할 때 유용하다.
  2. caller: 함수 자신을 호출한 함수. 사양에 포함되지 않은 비표준 프로퍼티이며, 앞으로 표준화 예정도 없다.
  3. length: 함수를 정의할 때 선언한 매개변수의 개수.
  4. name: 함수 이름. 익명 함수 표현식의 경우, ES5에서는 빈 문자열. ES6에서는 함수 객체를 가리키는 식별자를 값으로 갖는다.
  5. __proto__: [[Prototype]] 내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 '접근자 프로퍼티'. 
  6. ptrototype: constructor 함수만 갖는 프로퍼티로, 함수가 객체를 생성하는 생성자 함수로 호출될 때, 생성자 함수가 생성할 인스턴스의 프로토타입 객체를 가리킨다.
---
# 프로토타입
  - 자바스크립트는 프로토타입 기반의 객체지향 프로그래밍 언어.
  - ES6부터 도입된 클래스. 새로운 객체 생성 메커니즘이다.
# 객체 지향 프로그래밍
  - 실세계의 실체를 인식하는 철학적 사고를 프로그래밍에 접목하려는 시도.
  - 실체는 특징이나 성질을 나타내는 속성(attribute/property)을 가지고 있고, 이를 통해 실체를 인식, 구분.
  - 이러한 방식으로, 다양한 속성 중 프로그램에 필요한 속성만 간추려 표현하는 것이 추상화.
  - 이 추상화를 통해 객체를 다른 객체와 구별할 수 있다.
  - 즉, 객체는 여러 개의 값(속성)을 하나의 단위로 구성한 복합적인 자료구조.
  - 객체지향 프로그래밍은 독립적인 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임.
  - 이 때,
  - 객체의 속성은 상태(프로퍼티), 동작(메서드)로 구분할 수 있다.
  - 이 상태와 동작을 하나의 논리적인 단위로 묶은 게 함수고, 객체는 다른 객체와 메시지를 주고 받거나 데이터를 처리하거나,
  - 다른 객체의 상태 데이터나 동작을 상속받아 사용하기도 한다.(상속)
# 상속과 프로토타입
  - 상속은 객체지향 프로그래밍의 핵심 개념(코드의 재사용으로 개발 비용을 줄일 수 있는 잠재력이 있다)으로, 자바스크립트는 프로토타입을 기반으로 상속을 구현한다.
  - 가령, Circle 생성자 함수가 생성한 모든 인스턴스는 자신의 프로토타입, Cicle.prototype의 모든 프로퍼티와 메서드를 상속받는다.
  - 인스턴스에서 공통적으로 사용될 프로퍼티나 메서드를 Circle.prototype에 구현해두면?
  - 모든 인스턴스가 상속받아 사용할 수 있는 거지.
# 프로토타입 객체
  - 상속을 구현(목적)으로 사용.
  - 모든 객체는 [[Prototype]]이라는 내부 슬롯을 가지며, 이 내부 슬롯의 값이 프로토타입의 참조.(null인 경우도 있다.)
  - 동시에 프로토타입은 생성자 함수와 연결되어 있다.
  - 생성자 함수 <-> 프로토타입 <- 객체
  - 객체는 __proto__ 접근자 프로퍼티를 통해 자신의 프로토타입에 간접적으로 접근할 수 있으며,
  - 프로토타입은 자신의 constructor프로퍼티를 통해 생성자 함수에 접근할 수 있고,
  - 생성자 함수는 prototype프로퍼티를 통해 프로토타입에 접근할 수 있다.
# __prototype__ 접근자 프로퍼티
  1. __proto__ 는 접근자 프로퍼티다.
    - getter/setter 함수를 통해 프로토타입을 취득하거나 할당.
    - 프로토타입을 부르거나, 교체할 수 있다.
  2. __proto__ 접근자 프로퍼티는 상속을 통해 사용된다.
    - 기본적으로 __proto__는 Object.prototype의 프로퍼티.
    - 모든 객체의 프로토타입 체인상 끝에는 Object.prototype이 있으므로,
    - __proto__를 상속받아 사용할 수 있다.
  3. __proto__ 접근자 프로퍼티를 통해 프로토타입에 접근하는 이유.
    - __proto__은 순환참조를 막도록 구현되어 있다.
    - 단방향 리크드 리스트로 프로토타입 체인을 구현할 수 있다.
  4. __proto__ 접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 권장하지 않는다.
    - 직접 상속을 통해 Object.prototype을 상속받지 않는 객체를 만들 수 있다.
    - 이 경우 __proto__를 사용할 수 없으므로,
    - Object.getPrototypeOf, Object.setPrototypeOf 메서드를 사용한다.
    ```
    // obj 객체의 프로토타입을 취득
    Object.getPrototypeOf(obj); // obj.__proto__;
    // obj 객체의 프로토타입을 교체
    Object.setPrototypeOf(obj, parent); // obj.__proto__ = parent;
    ```
# 함수 객체의 prototype 프로퍼티
  - 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다.
  - 화살표 함수와 메서드 축약 표현으로 정의한 메서드는 non-constructor 함수로, prototype 프로퍼티를 가질 이유가 없지.
  - 생성자 함수를 목적으로 만들지 않은 함수도 prototype 프로퍼티를 가지고는 있다. 의미는 없지만.
# 프로토타입의 constructor 프로퍼티와 생성자 함수
  - prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다.
  - 프로토타입 체인 상 자식 역할의 객체도 상속받아 사용할 수 있다.
# 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입
  - 일단 결론은, Object.prototype을 프로토타입으로 갖는다.
  - 리터럴이 평가 될 때는 추상연산 OrdinaryObjectCreate가 호출되어 객체 등을 만드는데,
  - 프로퍼티 추가 처리 등의 세부 내용은 다르지만,
  - 추상연산을 호출한다는 점에서 Object() 함수를 이용한 방법과 동일하다.
  - 즉, 리터럴로 만든 객체, 함수, 배열, 정규 표현식은 각각 Object, Function, Array, RegExp 생성자 함수로 만든 각각과 같은 프로토타입을 갖는다.
# 프로토타입의 생성 시점
  - 생성자 함수가 생성되는 시점과 같다.
  - 즉 생성자 함수가 생성되면 동시에 프로토타입도 준비하는 건데,
  - 생성자 함수는 사용자 정의 생성자 함수와 빌트인 생성자 함수로 구분할 수 있다.
  1. 사용자 정의 생성자 함수와 프로토타입 생성 시점
    - 함수 정의가 평가 되어 함수 객체를 생성하는 시점에 프로토타입도 생성.
    - 그게 언제야?
    - 함수 선언문으로 정의된 생성자 함수는 런타임 이전에 평가.
    - 그때 만드는 거지, 뭐.
    - 이렇게 만들어진 프로토타입의 프로토타입은? Object.prototype.
  2. 빌트인 생성자 함수와 프로토타입 생성 시점
    - 모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성.
    - 이 때 같이 만들어지지.
  - 즉, 프로토타입은 이미 만들어져 준비되어 있는 거다!
# 객체 생성 방식과 프로토타입의 결정
  - 어떤 방식이든 추상연산 OrdinaryObjectCreate를 호출하는 건 동일,
  - 이 때 인수로 주어지는 프로토타입이 다른 거야.
# 프로토타입 체인
  - 사용자 정의 생성자 함수로 만들어진 프로토타입은 Object.prototype을 프로토타입으로 갖고,
  - 그 생성자 함수로 만든 객체는 그 함수.prototype을 프로토타입으로 가져,
  - 셋은 연결된다.
  - 이게 프로토타입 체인.
  - 객체의 프로퍼티나 메서드에 접근하려고 할 때, 해당 객체에 그 프로퍼티가 없으면 상위 프로토타입을 따라 가며 찾는다.
  - Object.prototype은 프로토타입 체인의 종점인데,
  - 여기까지 가서도 찾는 프로퍼티가 없으면 undefined.
  - 프로토타입 체인은 상속과 프로퍼티 검색을 위한 메커니즘이다.
  - 앞서 다뤘던 스코프 체인과 비슷하게 움직이는데,
  - 둘은 서로 협력하여 식별자와 프로퍼티를 검색하는데 사용한다.
# 오버라이딩과 프로퍼티 섀도잉
  - 상속받아 사용하던 프로퍼티와 같은 이름의 프로퍼티를 인스턴스에 추가했을 때,
  - 프로토타입 프로퍼티에 덮어쓰는 게 아니라, 인스턴스 프로퍼티로 추가.
  - 사용되어지는 것도 인스턴스 프로퍼티.
  - 삭제하면 없어지는 것도 인스턴스 프로퍼티.
  - 이 때, 인스턴스 프로퍼티가 프로토타입 메서드를 '오버라이딩' 했고, 이렇게 가려지는 현상을 '프로퍼티 섀도잉' 이라고 한다.
# 프로토타입의 교체
  1. 생성자 함수에 의한 프로토타입의 교체
    - 프로토타입으로 쓸 객체를 재할당 하면 되지.
    - 이때 교체한 프로토타입에는 constructor 프로퍼티가 없지.
    - 따라서 인스턴스의 생성자 함수를 찾으면 상위의 Object가 나올 거야.
    - 동적 추가로 새 프로토타입에 constructor 프로퍼티를 만들 수 있다.
  2. 인스턴스에 의한 프로토타입의 교체
    ```
    Object.setPrototypeOf(me, parent);
    // 위 코드는 아래의 코드와 동일하게 동작한다.
    // me.__proto__ = parent;
    ```
    - 이 경우도 새 프로토타입이 constructor가 없지
    - 그건 위와 같지만,
    - 차이는 생성자 함수의 prototype 프로퍼티가 새 프로토타입을 가리키냐 아니냐.
    - 이것도 재설정 할수 있다.(재할당)
  - 이처럼 프로토타입 교체를 통해 상속 관계를 변경하는 것은 번거롭다.
  - 직접 상속이나 클래스가 편함.
# instanceof 연산자
  - 좌항에 위차한 객체의 프로토타입 체인에, 우변의 생성자 함수가 있으면 트루, 아니먼 펄스.
  - 프로토타입인지를 확인하는 게 아니라, 프로토타입 체인에 존재하는지를 확인한다.
# 직접 상속
  1. Object.create에 의한 직접 상속
  ```
  obj = Object.create(Object.prototype);
  ```
    - new 연산자 없이도 객체를 생성할 수 있다.
    - 프로토타입을 지정하면서 객체를 생성할 수 있다.
    - 객체 리터럴에 의해 생성된 객체도 상속받을 수 있다.
    - 그런데,
    - const obj = Object.create(null); 처럼 프로토타입 체인의 종점에 해당하는 객체를 만들 수도 있다.
    - 이때 Object.prototype 빌트인 메서드를 사용할 수 없으므로, 빌트인 메서드는 간접적으로 호출해서 써야 하는데,
    - 이 방법은 나중에.
  2. 객체 리터럴 내부에서 __proto__ 에 의한 직접 상속
    ```
    const obj = {
      y: 20,
      // 객체를 직접 상속받는다.
      // obj → myProto → Object.prototype → null
      __proto__: myProto
    };
    ```
# 정적 프로퍼티/메서드
  - 생성자 함수가 가지고 있는 프로퍼티/메서드.
  - 프로토타입에 있는 프로퍼티/메서드가 아니므로, 인스턴스가 참조/호출할 수 없지만,
  - 직접 호출할 수는 있다.
  - 참고로 프로토타입 프로퍼티/메서드를 표기할 때 prototype을 #으로 표기(예를 들어, Object.prototype.isPrototypeOf를 Object#isPrototypeOf으로 표기)하는 경우도 있으니 알아두도록 하자.
# 프로퍼티 존재 확인
  1. in 연산자
    ```
    const person = {
      name: 'Lee',
      address: 'Seoul'
    };

    // person 객체에 name 프로퍼티가 존재한다.
    console.log('name' in person);    // true
    ```
    - 객체 내 프로퍼티가 존재하는지 여부 확인.
    - 상속받은 모든 프로퍼티를 확인한다.
    - 같은 동작으로
    ```
    Reflect.has(person, 'name')
    ```
  2. Object.prototype.hasOwnProperty 메서드
    ```
    person.hasOwnProperty('name')
    ```
    - 상속받은 프로퍼티는 빼고, 객체 고유의 프로퍼티인 경우에만 트루.
# 프로퍼티 열거
  1. for...in 문
    ```
    const person = {
      name: 'Lee',
      address: 'Seoul'
    };

    // for...in 문의 변수 prop에 person 객체의 프로퍼티 키가 할당된다.
    for (const key in person) {
      console.log(key + ': ' + person[key]);
    }
    // name: Lee
    // address: Seoul
    ```
    - in 연산자처럼 상속받은 프로퍼티까지 열거.
    - 단 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false인 경우는 열거 안함.
    - 상속받은 프로퍼티는 제외하고 객체 자신의 프로퍼티 만을 열거하려면 Object.prototype.hasOwnProperty 메서드를 사용해서 방어코드 작성.
    ```
    const person = {
      name: 'Lee',
      address: 'Seoul',
      __proto__: { age: 20 }
    };

    for (const key in person) {
      // 객체 자신의 프로퍼티인지 확인한다.
      if (!person.hasOwnProperty(key)) continue;
      console.log(key + ': ' + person[key]);
    }
    // name: Lee
    // address: Seoul
    ```
    - for...in 문은 프로퍼티를 열거할 때 순서를 보장하지 않는다.
    - 배열에는 for 문이나 for…of 문 또는 Array.prototype.forEach 메서드를 사용하기를 권장. 배열에서 다시.
  2. Object.keys/values/entries 메서드
    - 객체 자신의 고유 프로퍼티만 열거.
    - Object.keys: 객체 자신의 열거 가능한(enumerable) 프로퍼티 키를 배열로 반환한다.
    - Object.values: 객체 자신의 열거 가능한 프로퍼티 값을 배열로 반환한다.
    - Object.entries: 객체 자신의 열거 가능한 프로퍼티 키와 값의 쌍의 배열을 배열에 담아 반환한다.
---
# 빌트인 객체
# 자바스크립트 객체의 분류
  1. 표준 빌트인 객체: ECMAScript 사양에 정의된 객체. 애플리케이션 전역의 공통 기능을 제공. 전역 객체의 프로퍼티로서 제공된다. 따라서, 별도의 선언없이 언제나 참조할 수 있다.
  2. 호스트 객체: 자바스크립트 실행 환경이 추가로 제공하는 객체.
  3. 사용자 정의 객체: 사용자가 직접 정의한 객체
# 표준 빌트인 객체
  - Objet, String, Number, Boolean, Symbol, Date, Math, Array 등, 자바스크립트가 제공하는 표준 빌트인 객체.
  - Math, Reflect, JSON을 제외한 모든 표준 빌트인 객체는 인스턴스를 생성할 수 있다.
  - 인스턴스를 생성할 수 있단 건, 정적 메서드와 프로토타입 메서드를 제공한다는 거지.
  - 아닌 건 정적 메서드만 제공하는 거고.
  - 표준 빌트인 객체가 생성한 인스턴스의 프로토타입은, 그 표준 빌트인 객체의 prototype 프로퍼티에 바인딩된 객체다.
  - 이 프로토타입이 다양한 프로토타입 메서드를 제공.
# 원시값과 래퍼 객체
  - 원시값을 마치 객체처럼 접근할 수 있는데(ex. str.length),
  - 이 때 자바스크립트 엔진은 일시적으로 원시값을 연관된 객체로 변환.
  - 객체로 아주 바꾸는 건 아니고, 할 일 다 하면 버림.
  - 아무튼 이때 생성되는 임시 객체를 '래퍼 객체'라 한다.
  - 객체가 되었으니 프로토타입의 메서드를 갖다 쓸 수도 있지.
  - 문자열, 숫자, 불리언, 심벌이 이렇게 움직이는데,
  - 불리언은 쓸 일이 없고, 심벌은 나중에 배움.
  - 그외 null과 undefined는 래퍼 객체를 생성하지 않는다.
# 전역 객체
  - 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며, 어떤 객체에도 속하지 않은 최상위 객체이다.
  - 프로토타입 체인상 최상위는 아님. 당연하지. 프로토타입이 아닌데.
# 빌트인 전역 프로퍼티
  - 전역 객체의 프로퍼티.
  주로 애플리케이션 전역에서 사용하는 값을 제공.
  1. Infinity
  2. NaN
  3. undefined
# 빌트인 전역 함수
  - 전역 객체의 메서드
  - 전역에서 호출 가능.
  1. eval
    - 금지라는데 일아야 하나?
  2. isFinite
    - 전달받은 인수가 정상적인 유한수인지 검사하여 유한수이면 true를 반환하고, 무한수이면 false를 반환한다.
    - NaN으로 평가되면 false.
    - null은 0으로 변환되므로 true.
  3. isNaN
    - 전달받은 인수가 NaN인지 검사하여 그 결과를 불리언 타입으로 반환한다.
  4. parseFloat
    - 전달받은 문자열 인수를 실수로 해석(parsing)하여 반환.
  5. parseInt
    - 전달받은 문자열 인수를 정수(integer)로 해석(parsing)하여 반환.
    - 두 번째 인수로 진법을 나타내는 기수(2 ~ 36)를 전달할 수 있다.
    ```
    // '10'을 2진수로 해석하고 그 결과를 10진수 정수로 반환한다
    parseInt('10', 2); // -> 2
    ```
    - 기수를 지정하여 10진수 숫자를 해당 기수의 문자열로 변환하여 반환하고 싶을 때는 Number.prototype.toString 메서드(“28.3.8. Number.prototype.toString” 참고)를 사용.
  6. encodeURI / decodeURI
    - encodeURI 함수는 완전한 URI(Uniform Resource Identifier)를 문자열로 전달받아 이스케이프 처리를 위해 인코딩한다.
  7. encodeURIComponent / decodeURIComponent
    - encodeURIComponent 함수는 전달된 URI(Uniform Resource Identifier) 구성 요소(component)를 인코딩한다. 
# 암묵적 전역
  - 선언하지 않은 식별자에 값을 할당하면 전역 객체의 프로퍼티가 된다.
  - 전역 객체의 프로퍼티가 되어 마치 전역 변수처럼 동작한다.
  - 변수는 아니므로, 호이스팅은 발생하지 않는다.
  - 단지 프로퍼티니까, delete 연산자로 삭제할 수 있다.