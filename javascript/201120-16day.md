# 1바이트가 8비트인 이유
  - 내가 순서대로 말해볼게, 들어봐.
    1. 1바이트=8비트 라고 결정되지 않은 때가 있었어.
    2. 처음 아이디어는 1바이트에 한 글자를 표현할 수 있도록 하고 싶었지.
    3. 영어 대소문자와 숫자, 공백과 몇 개의 특수문자, 그 외 출력 불가능한 제어 문자들(?)을 표현하려면 100개 남짓의 가짓수가 필요하겠지?
    4. 컴퓨터는 2진수로 값을 저장하니까, 2의 7승(128)이면 다 담을 수 있지.
    5. 그래서 1바이트->표현하고 싶은 글자들 중 하나->7비트 였는데,
    6. 후에 영어가 아닌 다른 언어도 넣고 싶어서 8비트로 확장했어.
    7. 그때부터 규격이 정해지고 표준화 됨.
    9. ㅇㅇ?
    10. 근데 세상엔 너무 많은 언어가 있잖아.
    11. 2의 8승으로 그게 다 표현 안 되지.
    12. 그래서,
    13. 세계 모든 언어를 같은 방법으로 인코딩하고 싶은 유니코드는, 한 글자를 표현하기 위해 2바이트를 써.
    14. 2바이트, 8비트*8비트, 2의8승*2의8승 = 65536.
    15. 더 필요할 거 같은데, 그 이후로 어떻게 됐지?
  - https://ko.wikipedia.org/wiki/ASCII
  - https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C
  - https://zepeh.tistory.com/313
  - https://namu.wiki/w/%EC%95%84%EC%8A%A4%ED%82%A4%20%EC%BD%94%EB%93%9C
  - https://whatisthenext.tistory.com/103
---
# 연산자
  - 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산(operation) 등을 수행해 하나의 값을 만든다.
  - 피연산자: 연산의 대상, 표현식이어야 함,
  - 피연산자와 연산자로 만들어진 문도 값으로 평가될 수 있어 표현식.
# 산술 연산자
  - 수학적 연산으로 숫자 값을 만든다.
  - 수학적 연산이 불가할 경우, NaN값.
  - 피연산자의 개수에 따라 이항 산술 연산자, 단항 산술 연산자.
  1. 이항 산술 연산자
    - +, -, / *, %
    - 새로운 값을 만들어낸다.
    - 피연산자의 값을 변경하는 '부수 효과' 없음.
  2. 단항 산술 연산자
    - ++, --, +, -
    - ++, -- 는 피연산자의 값을 변경, '부수 효과'.
    - +는 아무 효과도 없어 보이지만, 숫자 타입이 아닌 값을 숫자 타입으로 바꿈. 단, 피연산자의 값을 변경하지는 않음.
    - -도 +와 같이 피연산자의 값을 숫자 타입으로 바꿈.
  3. 문자열 연결 연산자
    - +
    - 피연산자 중 하나가 문자열 타입일 때, 나머지도 문자열로 바꾸고 합침.
    - 문자열 연결 연산자.
    - 단항 산술 연산자의 +, -와 함께, '암묵적 타입 변환'을 일으킴.
# 할당 연산자
  - =, +=, -=, *=, /=, %=, **=
  - 우항의 결과를 좌항의 변수에 할당.
  - 할당문은 값으로 평가되는 표현식인 문.
# 비교 연산자
  - 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환.
  1. 동등/일치 비교 연산자
    - ==, ===
    - 동등 비교 연산자(==)는 암묵적 타입 변환을 통해 두 피연산자의 타입을 일치 시킨 후 비교.
    - 일치 피교 연산자(===)는 암묵적 타입 변환을 하지 않고, 두 피연산자를 비교. 타입이 다르면 false.
    - 일치 피교 연산자로 비교했을 때, NaN값은 자신과 일치하지 않는 유일한 값.
    - 0도 양의 0과 음의 0을 같다고 비교함.
    - 메소드인 Object.is()을 쓰면 +0과 -0도 동일, NaN도 자신과 동일하다고 표시함.
    - !=, !==
  2. 대소 관계 비교 연산자
    - <, >, <=, >= 
# 삼항 조건 연산자
  - 조건식의 평가 결과(불리언으로 평가)에 따라 반환할 값을 결정.
  - (조건식) ? (트루일 때 반환 값) : (펄스일 때 반환 값)
  - 조건식을 사용하므로, 조건문.
  - if...else 문과 유사하게 사용 가능.
  - 단, 삼항 조건 연산자는 값으로 평가 가능, if...else 문은 값으로 평가 불가.
  - 삼항 조건 연산자는 표현식, if...else문은 평가식이 아님.
  - 그래서, 값을 결정해야 한다면 삼항 조건 연산자를 사용하고,
  - 조건에 따라 수행해야 할 문이 많은 경우에는 if...else.
# 논리 연산자
  - ||, &&, !
  - !는 피연산자를 불리언 속성으로 변환, 부정하여 반환.
  - 불리언 속성이 아닌 값을 불리언 속성으로 바꿀 수 있다. -> !!값
  - ||, &&는 불리언 값만 반환하는 게 아니야,
    1. 양쪽의 피연산자 중 하나를 반환.
    2. 불리언 타입이 아닌 값은 불리언 타입으로 변환하여 평가, 피연산자 중 하나를 반환.
    3. 단축 평가
# 쉼표 연산자
  - ,
  - 왼쪽부터 평가를 시작해 마지막 피연산자의 값을 반환.
# 그룹 연산자
  - (, )
  - 연산자 우선순위가 가장 높다.
  - 연산자 우선순위를 명시적으로 표시할 수 있다.
# typeof 연산자
  - typeof
  - 데이터 타입을 문자열로 반환.
  - null 타입은 undefined로 반환하는데, 버그임.
  - 선언되지 않은 식별자를 연산하면 undefined를 반환.
# 지수 연산자
  - **
  - Math.pow()
  - 이항 연산자 중에서 우선순위가 가장 높다.
  - 할당 연산자와 함께 쓸 수 있따. **=
  - 음수의 거듭제곱의 경우 음수를 ()로 묶어줘서 사용.
# 그외 연산자
  - ?., ??, delete, new, instanceof, in
  - 다른 주제와 연관되어 있으므로, 그때 다시.
# 연산자 우선순위
  - () 가 제일 높고,
  - 그 아래로 단항 산술 연산자
  - 이항 산술 연산자(그 중에 **이 가장 높다.)
  - 비교 연산자
  - 동등/일치 연산자
  - 논리 연산자
  - 삼항
  - 할당
  - -> 외우기 어려움. (, ) 로 명시적으로 표시가 필요하다.
---
# 제어문
  - 위에서 아래로 한 줄씩 진행되는 코드 진행 방향을 제어.
  - 조건문, 반복문
  - 코드 흐름이 왔다갔다 하면 가독성이 떨어지는데, 후에 살펴볼 고차 함수가 이를 해결하려 노력.
  - 하지만 일단 이거부터 해야지.
# 블록문
  - 0개 이상의 문을 중괄호({, })로 묶은 것, 코드 블록, 블록.
  - 블록문을 하나의 실행 단위로 취급한다.
  - 자체 종결성을 갖기 때문에 뒤에 ;을 붙이지 않는다.
  - 일반적으로 제어문이나 함수에 사용한다.
  - 제어문과 함수의 형식에 중괄호가 있는 게 아니라, 블록문이 따로 있는 거.
  - 그러니까 제어문과 함수에서 한 줄의 문만 있을 땐 블록문을 안 써도 되지.
# 조건문
  - 조건식의 평가 결과에 따라 블록의 실행을 결정.
  - if...else문과 switch...case문.
  1. if...else
    - 조건식을 불리언 타입으로 평가하여 트루면 if의 블록 실행, 펄스면 else의 블록 실행.
    - 평가된 조건식의 값이 불리언 타입이 아니더라도, 불리언 타입으로 암묵적 변환.
    - 조건식을 추가하고 싶으면 else if를 사용.
    - 삼항 조건 연산자로 바꿔 쓸 수 있다.
  2. switch
    - 조건식을 평가하여, 그 값과 일치하는 case로 실행 흐름을 옮긴다.
    - : 이후의 문들을 실행하고,
    - break로 빠져나간다.
      1. break가 없을 경우,
      2. 가장 아래의 default를 실행.
      3. 이것을 폴스루(fall through)라고 한다.
      4. 이걸 이용할 수도 있는데,
      ```
      var year = 2000; // 2000년은 윤년으로 2월이 29일이다.
      var month = 2;
      var days = 0;

      switch (month) {
        case 1: case 3: case 5: case 7: case 8: case 10: case 12:
          days = 31;
          break;
        case 4: case 6: case 9: case 11:
          days = 30;
          break;
        case 2:
          // 윤년 계산 알고리즘
          // 1. 연도가 4로 나누어떨어지는 해(2000, 2004, 2008, 2012, 2016, 2020...)는 윤년이다.
          // 2. 연도가 4로 나누어떨어지더라도 연도가 100으로 나누어떨어지는 해(2000, 2100, 2200...)는 평년이다.
          // 3. 연도가 400으로 나누어떨어지는 해(2000, 2400, 2800...)는 윤년이다.
          days = ((year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0)) ? 29 : 28;
          break;
        default:
          console.log('Invalid month');
      }
      ```
    - case, default, break 등 다양한 키워드가 사용되고, 폴 스루가 적용되는 등, if...else보다 문법적으로 어려워.
    - if...else를 쓸 수 있으면 쓰는데, 조건이 너무 많은 경우에는 switch가 가독성이 좋다.
# 반복문
  - 조건식이 참일 경우, 거짓이 될 때까지 블록을 반복.
  - for, while, do...while
  1. for문
    ```
    for (var i = 0; i < 10; i++) {
      console.log(i);
    }
    ```
    - 선언문, 조건식, 증감식은 모두 옵션으로 안 써도 돼. 안 쓰면 무한 루프.
    - for문 안에 for문으로 중첩 가능.
  2. while 문
    ```
    while (count < 3) {
      console.log(count); // 0 1 2
      count++;
    }
    ```
    - 블록 안에 if문, break문으로 탈출 가능.
  3. do...while 문
    ```
    do {
      console.log(count);
      count++;
    } while (count < 3); // 0 1 2
    ```
    - do를 먼저 실행하므로, 무조건 한 번은 실행.
  4. break 문
    - 레이블 문, 반복문(for, for…in, for…of, while, do…while) 또는 switch 문의 코드 블록을 탈출
    - 그 외의 문에서 사용하면 문법 에러.
    - 레이블 문
      - 식별자가 붙은 문
      - 식별자: 문;
      - 문 앞에 식별자: 를 붙여 이름을 붙인다.
      - 변수처럼 다시 부르기 위한 용도는 아니고, break 문을 사용하기 위한 별칭으로 사용.
    - 레이블 for문(식별자가 달린 for문)을 탈출할 때 유용하지만, 다른 경우는 사용을 권장하지 않아.
    - 그외 레이블 문을 사용하면 프로그램의 흐름이 복잡해져서 가독성이 나빠지고 오류를 발생시킬 가능성이 높아지기 때문.
  5. continue 문
    - 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동.
    - 반복문 자체를 탈출하지는 않음.
---
# 타입 변환
  - 명시적 타입 변환과 암묵적 타입 변환
  - 숫자 타입, 문자열 타입, 불리언 타입으로 변환.
  - 기존 원시값을 직접 변환하는 것은 아니고, 다른 타입의 새로운 원시값을 생성.
  - 재할당되지도 않고 한번 쓰고 버리므로, 재사용하기 위해서는 할당이 필요.
  - 암묵적 타입 변경은 개발자의 의지가 코드에 명백히 나타나지 않는다.
  - 그러면 데이터 타입의 추측이 어려워지고,
  - 오류를 생산할 가능성이 높아진다.
  - 암묵적 타입 변환이 이루어지지 않도록 코딩할 수도 있겠지만, 가독성 상 암묵적 타입 변환을 잘 이해하는 편이 좋다.
# 암묵적 타입 변환
  - 자바스크립트 엔진이 개발자의 의도와 상관없이 코드의 문맥을 고려해 데이터 타입을 강제 변환.
  - 가급적 에러를 발생시키지 않기 위해
  1. 문자열 타입으로 변환
    - 문자열 연결 연산자 1 + '2'
    - 템플릿 리터널의 표현식 삽입 '1 + 1 = &{1 + 1}' -> 숫자 타입으로 평가된 표현식을 문자열 타입으로 변환.
    - 참고
      ```
      // 숫자 타입
      0 + ''         // -> "0"
      -0 + ''        // -> "0"
      1 + ''         // -> "1"
      -1 + ''        // -> "-1"
      NaN + ''       // -> "NaN"
      Infinity + ''  // -> "Infinity"
      -Infinity + '' // -> "-Infinity"

      // 불리언 타입
      true + ''  // -> "true"
      false + '' // -> "false"

      // null 타입
      null + '' // -> "null"

      // undefined 타입
      undefined + '' // -> "undefined"

      // 심벌 타입
      (Symbol()) + '' // -> TypeError: Cannot convert a Symbol value to a string

      // 객체 타입
      ({}) + ''           // -> "[object Object]"
      Math + ''           // -> "[object Math]"
      [] + ''             // -> ""
      [10, 20] + ''       // -> "10,20"
      (function(){}) + '' // -> "function(){}"
      Array + ''          // -> "function Array() { [native code] }"
      ```
  2. 숫자 타입으로 변환
    - +를 제외한 이항 산술 연산자 -,*,/,%
    - 단항 산술 연산자 +
    - 비교 연산자 >,< -> 크기를 비교에 불리언 값을 반환. 크기를 비교하려면 피연산자 모두 숫자 타입이어야지.
    - 참고
      ```
      // 문자열 타입
      +''       // -> 0
      +'0'      // -> 0
      +'1'      // -> 1
      +'string' // -> NaN

      // 불리언 타입
      +true     // -> 1
      +false    // -> 0

      // null 타입
      +null     // -> 0

      // undefined 타입
      +undefined // -> NaN

      // 심벌 타입
      +Symbol() // -> ypeError: Cannot convert a Symbol value to a number

      // 객체 타입
      +{}             // -> NaN
      +[]             // -> 0
      +[10, 20]       // -> NaN
      +(function(){}) // -> NaN
      ```
      - 객체, 빈 배열이 아닌 배열, undefined는 NaN으로 반환
  3. 불리언 타입으로 변환
    - if문, for문, 삼항 조건 연산자 등의 조건식
    - falsy 값 여섯 개
      1. false
      2. undefined
      3. null
      4. 0, -0
      5. NaN
      6. ’’ (빈 문자열)
    - 나머지는 모두 truthy값
# 명시적 타입 변환
  - 개발자의 의도에 따라 명시적으로 타입을 변경
  - 빌트인 생성자 함수를 new 연산자 없이 호출하는 방법, 빌트인 메서드를 사용, 암묵적 타입 변환을 이용.
  1. 문자열 타입으로 변환
    1. String(1);
    2. (1).toString();
    3. 1 + '';
  2. 숫자 타입으로 변환
    1. Number('0');
    2. parseInt('0');
    3. +'0';
  3. 불리언 타입으로 변환
    1. Boolean('x');
    2. !!'x';
---
# 단축 평가
  - 논리 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다.
  ```
  'Cat' && 'Dog' // -> "Dog"
  ```
  - 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환.
  - 이 단축 평가로 if문을 대체할 수 있다.
  - if문의 조건이 truthy값일 때 무얼 해야 한다면 && -> 앞의 피연산자가 트루일 때, 뒤 피연산자를 반환하니까.
  - if문의 조건이 falsy값일 때 무얼 해야 한다면 || -> 앞의 피연산자가 펄스일 때, 뒤 피연산자를 반환하니까.
    - 삼항 조건 연산자는 if...else문을 대체할 수 있다.
    ```
    if (done) message = '완료';
    else      message = '미완료';
    console.log(message); // 완료

    // if...else 문은 삼항 조건 연산자로 대체 가능하다.
    message = done ? '완료' : '미완료';
    console.log(message); // 완료
    ```
  - 객체와 함수에서의 단축 평가 사용
    1. 객체를 가리키기를 기대하는 변수가 null 또는 undefined이 아닌지 확인하고 프로퍼티를 참조할 때.
      - 값이 null, undefined인 변수를 객체인 줄 알고 프로퍼티를 참조하면, 타입 에러TypeError, 프로그램 강제 종료.
      - 이 때, && 단축 평가를 사용하는 거지.
      ```
      var elem = null;
      var value = elem && elem.value;
      ```
    2. 함수 매개변수에 기본값을 설정할 때.
      - 함수를 호출할 때 인수를 전달하지 않으면 매개변수는 undefined를 갖는다. -> 에러
      - 이 때, || 단축 평가를 먼저 하고 함수 내용을 쓰는 거지.
      ```
      function getStringLength(str) {
        str = str || '';
        return str.length;
      }
      ```
      - 인수를 전달 받지 못한 경우, str은 false가 되고, 뒤 피연산자인 ''를 반환.
# 옵셔널 체이닝 연산자
  - ?.
  - 좌항의 피연산자가 null 또는 undefined일 경우, undefined를 반환.
  - 그렇지 않으면 우항의 프로퍼티 참조를 계속.
    ```
    var value = elem?.value;
    ```
  - 이전에는 && 단축 평가를 사용했다.
  - && 단축 평가는 null, undefined 외에도 falsy값이면 우항의 프로퍼티 참조를 계속 하는데,
  - falsy값인 0이나 ''(빈 문자열)은 객체로 평가될 때도 있어서 오류를 일으킴
# null 병합 연산자
  - 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환하고,
  - 그렇지 않으면 좌항의 피연산자를 반환.
  - 변수의 기본값을 설정할 때 유용.
    ```
    var foo = null ?? 'default string';
    ```
  - 이전에는 || 연산자를 써서 사용했음
  - 이거 뭔지 잘 모르겠는데?
---
# 용어
  1. 표준 빌트인 생성자 함수와 빌트인 메서드
    - 표준 빌트인(built-in) 생성자 함수와 표준 빌트인 메서드는 자바스크립트에서 기본 제공하는 함수이다. 표준 빌트인 생성자 함수는 객체를 생성하기 위한 함수이며 new 연산자와 함께 호출한다. 표준 빌트인 메서드는 자바스크립트에서 기본 제공하는 빌트인 객체의 메서드다.